= NAME

Getopt::Advance - An advance command line option parsing tools.

= SYNOPSIS

[source,perl6]
-------------------------------
#!/usr/bin/env perl6

use Getopt::Advance;
use Getopt::Advance::Helper;
use Getopt::Advance::Exception;

my @files = [];
my OptionSet $optset .= new;

$optset.insert-pos(
    "directory",
    0,
    sub ($, $dirarg) {
        die "$dirarg: Not a valid directory" if $dirarg.value.IO !~~ :d;
        @files = gather &find($dirarg.value.IO);
    }
);
$optset.append(
    "h|help=b"      => "print this help.",
    "v|version=b"   => "print program version.",
    "?=b"           => "same as -h.",
    :multi
);
$optset.append(
    'd=b' => 'specify file type to directory',
    'l=b' => 'specify file type to symlink',
    'f=b' => 'specify file type to normal file',
    :radio
);
for <d l f> -> $t {
    $optset.set-callback(
        $t,
        -> $, $ { @files = @files.grep({ ."{$t}"(); }); }
    );
}
$optset.push(
    'size=i',
    'the minimum size limit of file.',
    callback => sub ($, $size) {
        @files = @files.grep({ .s() >= $size.Int; });
    }
);
$optset.insert-main(
    sub main($optset, @args) {
        return 0 if $optset<help> || $optset<version>;
        if $optset.get-pos('directory', 0).?success {
            @args.shift;
        } else {
            &ga-want-helper();
        }
        my $regex = +@args > 0 ?? @args.shift.value !! "";

        if $regex eq "" {
            .path.say for @files;
        } else {
            .path.say if .path ~~ /<$regex>/ for @files;
        }
    }
);
&getopt($optset, :autohv, helper => &ga-helper2);

sub find($dir) {
    for $dir.dir() -> $f {
        take $f;
        if $f ~~ :d {
            &find($f);
        }
    }
}
-------------------------------


.The help of script:
[source,sh]
-------------------
Usage:
    ./find-file.p6 <directory>  [-h|--help] [-v|--version] [-?] [--size=<integer>] [-d] [-l] [-f]  *@args

    -h|--help         print this help.

    -v|--version      print program version.

    -?                same as -h.

    --size=<integer>  the minimum size limit of file.

    -d                specify file type to directory

    -l                specify file type to symlink

    -f                specify file type to normal file
-------------------

= DESCRIPTION

`Getopt::Advance` is a powerful command line option parsing module, it suppot many
style such as: `unix-style`、`gnu-style`、`bsd-style`.etc. It support `Hash`、`Array`
option compared to traditional command line tools. In addition, it also support
`radio`、`multi` group mechanism which can manage option realtionship. And to handle
non-option argument, it provide `main`、`pos` and `cmd` feature.

== `&getopt`

Sub `&getopt` accept one or multi `OptionSet`, pass it and command line argument
to the `&parser`. Once an `OptionSet` matching success, it will return an instance
of `Getopt::Advance::ReturnValue`. When all `OptionSet` match failed, it will
produced the help message, and rethrow the exception or call `exit` end the script.

=== Return value

* class Getopt::Advance::ReturnValue
**    has $.optionset;
+
The OptionSet which mathed
**    has @.noa;
+
The left non-option argument
**    has %.return-value;
+
Return value of main, the key is main's id.

=== The help message

Sub `&getopt` will display the help message in the following cases:

* all of OptionSet match failed
* `&ga-want-helper` called
* `&ga-want-all-helper` called
* The OptionSet has option named `help`, and `:autohv` passed to `&getopt`.

=== Exception

If an `OptionSet` match failed, consider follow serveral situation:

* default
+
`&getopt` will print helper(when help generator `&helper` defined) of current
`OptionSet`, print error message, and rethrow the exception.

* X::GA::ParseFailed
+
The `&parser` will call `&ga-try-next` throw an X::GA::ParseFailed exception
when `OptionSet` match failed. When `&getopt` caught this exception, it will
try next `OptionSet` supplied. If no more `OptionSet`, it will print helper
(when help generator `&helper` defined) of all `OptionSet`,  print error message,
and rethrow the exception. The user also can throw this exception in
`&callback` of `Option`.

* X::GA::WantPrintHelper
+
The user can call `&ga-want-helper` ask `&parser` interrupt the parsing process,
and print help message of current `OptionSet`. `&getopt` will print helper (when
help generator `&helper` defined) of current `OptionSet` and exit with 0.

* X::GA::WantPrintAllHelper
+
The user can call `&ga-want-all-helper` ask `&parser` interrupt the parsing process,
and print help message of all `OptionSet`. `&getopt` will print helper(when
help generator `&helper` defined) of all `OptionSet` and exit with 0.

=== Signature

* getopt(@args = @*ARGS, Str $optstring, *%args)
* getopt(@args = @*ARGS, *@optsets,      *%args)

==== The positional argument

* @args
+
This is the command line argument passed to `&getopt`, the default value is `@*ARGS`.
And it means you can provide yours "command line argument" to `&getopt`.

NOTE: The sub `&getopt` will not modify `@*ARGS`.

==== The named argument of &getopt

* :&helper = &ga-helper
+
`&helper` will generate and display help message of `OptionSet`, default is `&ga-helper`.

* :$stdout = $*OUT
+
Help message will print to `$stdout`, default is `$*OUT`.

* :$stderr = $*ERR
+
Error message will print to `$stderr`, default is `$*ERR`.

* :$parser = &ga-parser
+
Command line argument parser, default is `&ga-parser`.

* :$strict = True
+
When `$strict` is True, argument of an option should not be start with `-` or `--`.

* :$autohv = False
+
When `$autohv` is True, `&getopt` will automate print `$version` information and help message.
The `:autohv` will not work if you don't have a option named `help` and `version`.
Without `:autohv`, you need deal the `help` or `version` manually.

* :$version
+
Program version information.

* :$bsd-style
+
When `$bsd-style` is True, `&parser` will accept bsd style option.

* :$x-style
+
When `$x-style` is True, x-style option have priority over unix-style.

== OptionSet

`OptionSet` is a set of `Option` as the literal mean.
It provide a lot of interface can manage many `Option`.

* new-from-optstring(Str $optstring is copy)

This method can convert the traditional option string, and create an OptionSet
contain options descripte by that string.

NOTE: You should use `&getopt(@args = @*ARGS, Str $optstring, *%args)` instead of this method.

* keys(::?CLASS::D:)

Return the name of all options.

* values(::?CLASS::D:)

Return all options of this `OptionSet`.

* get(::?CLASS::D: Str:D $name --> Option)

Return an option has the name `$name`.
If it not exist, it will return an type object `Option`.

* has(::?CLASS::D: Str:D $name --> Bool)

Return True if the option exist.

* has(::?CLASS::D: Str:D @name --> Bool)

Return True if all of the option exist.

* remove(::?CLASS::D: Str:D $name --> Bool)

Remove the option with the name `$name`, or return False if the option not exist.

=head1 Option

=head1 NonOption

=head1 Group

=head1 Types

=head1 Exception

=head1 Argument

=head1 Parser

=end pod
